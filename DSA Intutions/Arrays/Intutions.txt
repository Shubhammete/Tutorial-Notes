
########################## Arrays #############################################
# some tips

1) use int max = INTEGER.min and int min = INTEGER.max

2) swap elements
    int temp = a
    a = b
    b = temp

3) Reverse array
    start = 0, end = arr.length
    while(start<end){
    swap(arr,start,end)
    start++
    end--
    }

4) Order Agnostic Binary Search
    start = 0
    end = arr.length
    bool isAsc = arr[start]<arr[end]
    while(start<end){
        mid = start + (end - start)/2
        if(arr[mid] == target){
        return mid
        }
        if(isAsc){
            if(target<arr[mid]){
                end = mid-1
            }else{
                start = mid+1
            }
        }else{
            if(target<arr[mid]){
                start = mid+1
            }else{
                end = mid-1
            }
        }
    }

5) Find ceil and floor element
    # ceil element -> The smallest element in array which is greater than or equal to target
    # floor element -> The largest element in array which is smaller than or equal to target
       [1,4,6,8,11,16]
       target -> 7 or 8
       floor -> 8  or 8  -> return end
       ceil -> 11  or 8  -> return start

       here in BS we use while(start<=end) so
       end = start - 1 = arr.len - 1 (if ele not found)
       start = end + 1 = arr.len (if ele not found)

       In case of circular array if target is beyond last index return the first element
       so, we can use return[start % arr.len]
       so if start < arr.len it will return the index which is start
       if ele not found i.e. start = arr.len so arr.len % arr.len = 0 i.e first element

6) First and last index of occurrence

    First elem index = BS(arr,target,true) -> returns very first index
    last elem index = BS(arr,target,false) -> returns very last index

    so in BS if you find answer instead of returning it put it in variable and perform BS again until start<end
    BS(arr,target,findFirst)
    if(target == arr[mid]){
        ans = mid
        if(findFirst){
            end = mid - 1
        }else{
            start = mid + 1
        }
    }

7) Infinite sorted array
    Here the size of array is unknown so we cant do end = arr.len-1
    create chunks start with 2 and increase exponentially until target<end
    then perform binary search

    start = 0, end = 1
    while(target<arr[end]){
        new_start = end + 1
        end = end + (end - start + 1)*2
        start = new_start
    }
    return BS(arr,target,start,end)

8) Peak element in mountain array
    [1,2,3,5,6,4,3,2] here 6 is peak element

    Here condition for peak will be peak > peak-1 and peak > peak+1
     so if mid>mid+1 then are in descending part of array so end = mid as peak will be before mid or can be mid so -> end = mid
     and if mid< mid+1 then in ascending part so start = mid+1

     BS(arr,target){
        while(start<end){
        mid ....
        if(arr[mid]<arr[mid+1]){
            end = mid
        }else{
            start = mid + 1
        }
        }
        return arr[start] or arr[end]
     }

9) Search in mountain array
    - find peak element
    - search in asc and desc part and check peak == elem

10) Search in rotated sorted array
    - Find pivot i.e. the largest element in array
    - search on both side of pivot

    [4,5,6,1,2,3] -> pivot -> 6
    so, condition for pivot is that 6,1 is only descending part of array so search for that
    so, it satisfies two conditions mid > mid + 1 and mid < mid - 1

    while(start<end){
    if(mid > mid + 1){
        return mid
    }
    if(mid < mid - 1){
        return mid-1
    }
    if(start=<mid){
        // this is ascending part and ans will lie ahead
        start = mid + 1
    }
    if(start>=mid){
            // this is descending part and ans will lie behind
            end = mid - 1
        }
    }

    // now search in array

    if(pivot == element){
        return pivot
    }
    target is greater than start so it lies btw start and pivot as pivot is the greatest
    if(target>start){
        BS(arr,target,0 or start,pivot-1)
    }else{
        BS(arr,target,pivot+1,end)
    }

11) Rotation count
    pivot index + 1

12) Duplicate element in rotated array

    while(start<end){
        if(mid > mid + 1){
            return mid
        }
        if(mid < mid - 1){
            return mid-1
        }
        // check for duplicate
        if(start == mid && end == mid){

             // check if start and end is pivot
            if(start>start+1){
                return start
            }
            start++
            if(end < end-1){
                return end
            }
            end--

        }else if(start=<mid){
            // this is ascending part and ans will lie ahead
            start = mid + 1
        }else if(start>=mid){
                // this is descending part and ans will lie behind
                end = mid - 1
            }
        }


    

