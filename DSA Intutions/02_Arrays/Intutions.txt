
########################## Arrays #############################################
# some tips

1) use int max = INTEGER.min and int min = INTEGER.max

2) swap elements
    int temp = a
    a = b
    b = temp


3) Reverse array
    start = 0, end = arr.length
    while(start<end){
    swap(arr,start,end)
    start++
    end--
    }


4) Order Agnostic Binary Search

    start = 0
    end = arr.length
    bool isAsc = arr[start]<arr[end]
    while(start<end){
        mid = start + (end - start)/2
        if(arr[mid] == target){
        return mid
        }
        if(isAsc){
            if(target<arr[mid]){
                end = mid-1
            }else{
                start = mid+1
            }
        }else{
            if(target<arr[mid]){
                start = mid+1
            }else{
                end = mid-1
            }
        }
    }


5) Find ceil and floor element
    # ceil element -> The smallest element in array which is greater than or equal to target
    # floor element -> The largest element in array which is smaller than or equal to target
       [1,4,6,8,11,16]
       target -> 7 or 8
       floor -> 8  or 8  -> return end
       ceil -> 11  or 8  -> return start

       here in BS we use while(start<=end) so
       end = start - 1 = arr.len - 1 (if ele not found)
       start = end + 1 = arr.len (if ele not found)

       In case of circular array if target is beyond last index return the first element
       so, we can use return[start % arr.len]
       so if start < arr.len it will return the index which is start
       if ele not found i.e. start = arr.len so arr.len % arr.len = 0 i.e first element



6) First and last index of occurrence

    First elem index = BS(arr,target,true) -> returns very first index
    last elem index = BS(arr,target,false) -> returns very last index

    so in BS if you find answer instead of returning it put it in variable and perform BS again until start<end
    BS(arr,target,findFirst)
    if(target == arr[mid]){
        ans = mid
        if(findFirst){
            end = mid - 1
        }else{
            start = mid + 1
        }
    }



7) Infinite sorted array
    Here the size of array is unknown so we cant do end = arr.len-1
    create chunks start with 2 and increase exponentially until target<end
    then perform binary search

    start = 0, end = 1
    while(target<arr[end]){
        new_start = end + 1
        end = end + (end - start + 1)*2
        start = new_start
    }
    return BS(arr,target,start,end)



8) Peak element in mountain array
    [1,2,3,5,6,4,3,2] here 6 is peak element


     BS(arr,target){
        while(start<end){
        mid ....
    // check the condition for peak will be peak > peak-1 and peak > peak+1
        if(arr[mid]>arr[mid-1] && arr[mid]>arr[mid+1]){
                return arr[mid];
                }
    // if mid>mid+1 then are in descending part of array so end = mid as peak will be before mid or can be mid so -> end = mid
        if(arr[mid]>arr[mid+1]){
            end = mid
    // and if mid< mid+1 then in ascending part so start = mid+1
        }else{
            start = mid + 1
        }
        }
    // as start<end so start = end = peak at last
        return arr[start] or arr[end]
     }



9) Search in mountain array
    - find peak element
    - search in asc and desc part and check peak == elem



10) Search in rotated sorted array
    - Find pivot i.e. the largest element in array
    - search on both side of pivot

    [4,5,6,1,2,3] -> pivot -> 6
    so, condition for pivot is that 6,1 is only descending part of array so search for that
    so, it satisfies two conditions mid > mid + 1 (for 6 here) and mid < mid - 1 (for 1 here)

    while(start<end){
    if(mid > mid + 1){
        return mid
    }
    if(mid < mid - 1){
        return mid-1
    }
    if(start=<mid){
        // this is ascending part and ans will lie ahead
        start = mid + 1
    }
    if(start>=mid){
            // this is descending part and ans will lie behind
            end = mid - 1
        }
    }

    // now search in array

    if(pivot == element){
        return pivot
    }
    // target is greater than start so it lies btw start and pivot as pivot is the greatest
    if(target>start){
        BS(arr,target,0 or start,pivot-1)
    }else{
        BS(arr,target,pivot+1,end)
    }

11) Rotation count
    pivot index + 1

12) Duplicate element in rotated array

    while(start<end){
        int mid...

        if(mid > mid + 1){
            return mid
        }
        if(mid < mid - 1){
            return mid-1
        }
        // check for duplicate
        if(start == mid && end == mid){

             // check if start and end is pivot
            if(start>start+1){
                return start
            }
            start++
            if(end < end-1){
                return end-1
            }
            end--

        }else if(start<=mid){
            // this is ascending part and ans will lie ahead
            start = mid + 1
        }else if(start>=mid){
                // this is descending part and ans will lie behind
                end = mid - 1
            }
        }


13) Split the largest sum

    // find max element of array and sum of all elements in array as range
    // the use BS

    int sum = 0
    int pieces = 0
    // limit given for splitting an array is m
    while(start<end){

        // here mid is the sum estimated
        int mid = ....

        for(int no : arr){
            // check is sum is less than mid
            if(sum + num = mid){
                sum = num;
                pieces++
            }else{
            // add the elements in sum
                sum += num
            }

            // if pieces is less or same then mid is high so reduce mid
            if(pieces<=m){
                end = mid // here mid can be answer
            }else{
                // here pieces are more so mid is low so increase mid here
                start = mid + 1
            }
        }

    }

14) Binary Search in Row-col sorted matrix

    int row = 0;
    int col = arr.length -1;

    while(row < arr.length && col >= 0){
        if(arr[row][col] == target){
            return new int[]{row,col};
        }
    // target is greater skip col as all ahead elements are greater
        if(arr[row][col] > target){
            col--;
        }else{
        // target is smaller search in same column just increase row
            row++;
        }
        }

15) Binary Search in sorted matrix

    // no of rows and cols
    int rows = arr.length;
    int cols = arr[0].length;

    // here row start and end variables and col mid we can also reverse the roles
    int rowStart = 0;
    int rowEnd = rows - 1;
    int colMid = cols  / 2;

    // run while loop until two rows are remaining
    // loop break point --> rowStart == rowEnd - 1 -> rowStart = 0  rowEnd = 1
    while (rowStart < (rowEnd - 1)) {
        int mid = rowStart + (rowEnd - rowStart) / 2;
        if (arr[mid][colMid] == target) {
            return new int[]{mid, colMid};
        }
        if (arr[mid][colMid] < target) {
             rowStart = mid ;   // mid+1 and mid-1 will equate to each other so only mid and can be on same row
        }else{
             rowEnd = mid ;
        }
        }

        // check for elements in midCol
        if (arr[rowStart][colMid] == target) {
             return new int[]{rowStart, colMid};
        }
       if (arr[rowEnd][colMid] == target) {
             return new int[]{rowEnd, colMid};
      }


      // check for 1st half  -> smaller than target then go
      if (arr[rowStart][colMid - 1] >= target) {
             return BS(arr, target, rowStart, 0, colMid-1);
       }
      // 2nd half -> larger than target and smaller than end of that col
      if (arr[rowStart][colMid + 1] <= target  && target <= arr[rowStart][cols-1]) {
             return BS(arr, target, rowStart , colMid + 1, cols - 1);
            }
       // 3rd half
      if (arr[rowEnd][colMid - 1] >= target ) {
             return BS(arr, target, rowEnd, 0, colMid-1);
      }else{
                return BS(arr, target, rowEnd, colMid + 1, cols - 1);
            }


17) Bubble sort

            boolean swapped;
            for(int i = 0;i<arr.length;i++){
                swapped = false;

                // for each step, max item will come at  the last index
                for(int j = 1; j <arr.length - i;j++){

                    // swap the element if greater
                    if(arr[j]<arr[j-1]){
                        int temp = arr[j];
                        arr[j] = arr[j-1];
                        arr[j-1] = temp;
                        swapped = true;
                    }
                }
                // stopping conditions
                if(!swapped){
                    break;
                }


18) Selection Sort

        static int[] sort(int[] arr){
                for(int i = 0; i< arr.length;i++){
                    int lastIndex = arr.length-i-1;
                    int maxIndex = getMaxIndex(arr,0,lastIndex);
                    swap(arr,maxIndex,lastIndex);
                }
                return arr;
            }

        static int getMaxIndex(int[] arr, int start, int end) {
                int max = start;
                for(int i = start; i<=end;i++){
                    if(arr[max]<arr[i]){
                        max = i;
                    }
                }
                return max;
            }


19) Insertion sort

                static int[] sort(int[] arr){
                for(int i = 0;i< arr.length - 1;i++){  // i<= arr.len-2 coz j=i+1 and if i = 0 array is sorted up to index 1, so we need only n-1 indices
                    // j keeps checking to left, and strictly it must be less than 0
                    for (int j = i+1; j>0;j--){
                        // check only once as array on left side is already sorted
                        if(arr[j] < arr[j-1]){
                            swap(arr,j,j-1);
                        }else{
                            break;
                        }
                    }
                }
                return arr;

20) Cyclic sort


        static int[] sort(int[] arr){
            int i = 0;
            while(i<arr.length){
                if(arr[i] != arr[arr[i] -1]){
                    swap(arr,i,arr[i]-1);
                }else{
                    i++;
                }
            }
            return arr;
        }


21) Missing No

            while(i<arr.length){
                    int correctIndex = arr[i];
                    // here in case of arr[i] -1 keep arr[i] <= arr.length to count all index
                    if(arr[i] < arr.length && arr[i] != arr[correctIndex]){
                        swap(arr,i,correctIndex);
                    }else{
                        i++;
                    }
                }
                System.out.println(Arrays.toString(arr));
                for(int j = 0; j<arr.length;j++){
                    if(j !=arr[j]){
                        return j;
                    }
                }
                return arr.length;

22) Duplicate elements

               int i = 0;
               while(i<nums.length){
                   // check if element is at correct index
                   if(nums[i] != i+1){
                       // if not check correct index of element has element
                       if(nums[i] != nums[nums[i]-1]){
                           swap(nums,i,nums[i]-1);
                           // if yes then it is duplicate
                       }else{
                           return nums[i];
                       }
                   }else{
                       i++;
                   }
               }
               return -1;
           }


23) Mismatch pair

        static int[] MisMatch(int[] nums){

                int[] ans = new int[2]; // new array to store value and pair
                int i = 0;

                // sort the array
                while(i<nums.length){
                    if(nums[i] != nums[nums[i]-1]){
                        swap(nums,i,nums[i]-1);
                    }else{
                        i++;
                    }
                }
                // check for mismatch element and return pair
                for(int j = 0; j< nums.length;j++){
                    if(nums[j] != j+1   ){
                        return new int[]{nums[j],j+1};
                    }
                }

            return new int[]{-1};
        }


24) First Missing Positive

        static int MissingPositive(int[] arr){
            int i = 0;
            // sort the array
            while(i<arr.length){
                // check for positive numbers only
                if(arr[i]>0 && arr[i]<arr.length && arr[i] != arr[arr[i]-1]){
                    swap(arr,i,arr[i]-1);
                }else{
                    i++;
                }
            }

            // return first missing no
            for(int j = 0; j< arr.length; j++){
                if(arr[j] != j+1){
                    return j+1;
                }
            }
            // if element is last return array length + 1 in case of arr[i] + 1 and array length only in case of arr[i]
            return arr.length + 1;
        }


25)